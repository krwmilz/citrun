#
# Test that wrapping the 'cmake' build system produces instrumented binaries.
#
use strict;
use warnings;
use File::Which;
use Test::Cmd;
use Test::Differences;
use Test::More;
use t::utils;
unified_diff;

if (which 'cmake') {
	plan tests => 8;
} else {
	plan skip_all => 'cmake not found';
}

my $wrap = Test::Cmd->new( prog => 'citrun_wrap', workdir => '' );

$wrap->write( 'CMakeLists.txt', <<'EOF' );
cmake_minimum_required (VERSION 2.6)
project (program)
add_executable(program main.c)
EOF

# Log file after make is ran on Makefile generated by CMake.
my $log_good = <<EOF;
>> citrun_inst
CITRUN_COMPILERS = ''
PATH=''
Found source file ''
Modified command line is ''
Added clangtool argument ''
Instrumentation of '' finished:
    6 Lines of source code
    1 Function definitions
    1 Return statement values
    3 Total statements
Modified source written successfully.
Rewriting successful.
Forked compiler ''
Rewritten source compile successful
Restored ''
>> citrun_inst
CITRUN_COMPILERS = ''
PATH=''
Link detected, adding '' to command line.
Modified command line is ''
No source files found on command line.
EOF

$wrap->write( 'main.c', <<'EOF' );
int
main(void)
{
	return 0;
}
EOF

# Run CMake.
$wrap->run( args => 'cmake .', chdir => $wrap->curdir );

print $wrap->stdout;
is( $wrap->stderr,	'',	'is citrun_wrap cmake stderr empty');
is( $? >> 8,		0,	'is citrun_wrap cmake exit code 0');

# Ok now run regular make.
$wrap->run( args => 'make', chdir => $wrap->curdir );

my $log_out;
$wrap->read( \$log_out, 'citrun.log' );
$log_out = t::utils::clean_citrun_log($log_out);

eq_or_diff( $log_out, $log_good,	'is citrun.log identical', { context => 3 } );
print $wrap->stdout;
is( $wrap->stderr,	'',	'is citrun_wrap make stderr empty');
is( $? >> 8,		0,	'is citrun_wrap make exit code 0');

# Check the instrumented program runs.
$wrap->run( prog => $wrap->workdir . "/program", chdir => $wrap->curdir );

is( $wrap->stdout,	'',	'is program stdout empty');
is( $wrap->stderr,	'',	'is program stderr empty');
is( $? >> 8,		0,	'is program exit code 0');

#ok "is runtime shared memory file created" test -f procdir/program_*
