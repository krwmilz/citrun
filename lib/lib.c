/*
 * Copyright (c) 2016 Kyle Milz <kyle@0x30.net>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include <stdlib.h>		/* exit */
#include <stdio.h>		/* fprintf, stderr */
#include <string.h>		/* strncpy */

#include "lib.h"		/* struct citrun_header, struct citrun_node */
#include "lib_os.h"		/* citrun_{extend,os_info,open_fd} */


/*
 * The purpose of the instrumentation runtime is to create a file in a well
 * known location and constantly write counter information to it.
 *
 * Once the file is initially created it does not change in size. There is one
 * `struct citrun_node` per instrumented translation unit. The file is
 * structured like the following:
 *
 *   /tmp/citrun/a.out_XXXXXXX:
 *
 *   +-----------------------+
 *   | struct citrun_header  |
 *   | - citrun version      |
 *   | - process ids         |
 *   | - program name        |
 *   | - working directory   |
 *   | padding               |
 *   +-----------------------+
 *   | struct citrun_node 1  |
 *   | - source file paths   |
 *   | - counter buffer      | <-- size ~ lines in source file
 *   | padding               |
 *   +-----------------------+
 *   | struct citrun_node .. |
 *   | - source file paths   |
 *   | - counter buffer      |
 *   | padding               |
 *   + ----------------------+------
 *   | struct citrun_node N  |     ^
 *   | - source file paths   |     |-- sized for efficient memory access
 *   | - counter buffer      |     |
 *   | padding               |     v
 *   +-----------------------+------
 */

/*
 * Internal function that extends the file descriptor given as the first
 * argument and fills the extended space with version and runtime information.
 *
 * Returns a pointer to the beginning of the extended region on success.
 * The instrumented program will exit nonzero on failure.
 */
static struct citrun_header *
citrun_add_header(int fd)
{
	struct citrun_header	*new_header;

	new_header = citrun_extend(fd, sizeof(struct citrun_header));

	strncpy(new_header->magic, "ctrn", sizeof(new_header->magic));
	new_header->major = citrun_major;
	new_header->minor = citrun_minor;

	/* Fill in various runtime information fields. */
	citrun_os_info(new_header);

	return new_header;
}

/*
 * Public function called by code inserted into each translation unit. Takes a
 * version major and minor as the first two arguments and a pointer to an
 * existing `struct citrun_node` as the third argument.
 *
 * If the passed version numbers don't exactly match the version numbers this
 * library was compiled with a runtime error occurs. This means all instrumented
 * object files must be generated by the same citrun tools.
 *
 * The passed in `struct citrun_node` gets its fields copied to the runtime
 * file, and extra counter buffer space is allocated.
 *
 * Instrumented program will exit nonzero on failure.
 */
void
citrun_node_add(unsigned int major, unsigned int minor, struct citrun_node *n)
{
	size_t				 sz;
	struct citrun_node		*new;
	static struct citrun_header	*header = NULL;
	static int			 fd = 0;

	/* Binary compatibility between versions not guaranteed. */
	if (major != citrun_major || minor != citrun_minor) {
		fprintf(stderr, "libcitrun %i.%i: incompatible version %i.%i.\n"
			"Try cleaning and rebuilding your project.\n",
			citrun_major, citrun_minor, major, minor);
		exit(1);
	}

	if (header == NULL) {
		fd = citrun_open_fd();
		header = citrun_add_header(fd);
		citrun_start_viewer();
	}

	/* Allocate enough room for node and live execution buffers. */
	sz = sizeof(struct citrun_node);
	sz += n->size * sizeof(unsigned long long);
	new = citrun_extend(fd, sz);

	/* Increment accumulation fields in header. */
	header->units++;
	header->loc += n->size;

	/* Copy these fields from incoming node verbatim. */
	new->size = n->size;
	strncpy(new->comp_file_path, n->comp_file_path, CITRUN_PATH_MAX);
	strncpy(new->abs_file_path,  n->abs_file_path, CITRUN_PATH_MAX);
	new->comp_file_path[CITRUN_PATH_MAX - 1] = '\0';
	new->abs_file_path[CITRUN_PATH_MAX - 1] = '\0';

	/* Set incoming nodes data pointer to allocated space after struct. */
	n->data = (unsigned long long *)(new + 1);
}
